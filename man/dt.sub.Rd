% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dt_fun.R
\name{dt.sub}
\alias{dt.sub}
\title{In-place pattern matching and replacement in a data.table.}
\usage{
dt.sub(
  DT,
  pattern,
  replacement,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
}
\arguments{
\item{DT}{A \code{data.table}.}

\item{pattern}{A \code{character} string containing a regular expression
(or character string for fixed = TRUE) to be matched in
the given character vector. Coerced by as.character to a
character string if possible. If a character vector of
length 2 or more is supplied, the first element is used
with a warning.}

\item{replacement}{A \code{character} string replacement for matched pattern.
Coerced to character if possible. For fixed = FALSE this
can include backreferences "\1" to "\9" to parenthesized
subexpressions of pattern. For perl = TRUE only, it can
also contain "\U" or "\L" to convert the rest of the
replacement to upper or lower case and "\E" to end case
conversion. If a character vector of length 2 or more is
supplied, the first element is used with a warning. If NA,
all elements in the result corresponding to matches will
be set to NA.}

\item{ignore.case}{A \code{logical}. If FALSE, the pattern matching is case
sensitive and if TRUE, case is ignored during matching.}

\item{perl}{A \code{logical}. Should Perl-compatible regexps be used?}

\item{fixed}{A \code{logical}. If TRUE, pattern is a string to be
matched as is. Overrides all conflicting arguments.}

\item{useBytes}{A \code{logical}. If TRUE the matching is done
byte-by-byte rather than character-by-character.}
}
\value{
A \code{data.table}.
}
\description{
In-place pattern matching and replacement in a data.table.
}
\examples{
dtbl<-data.table(col1 = rev(seq(16)), col2=rep(x = c("hello", "world"), 8))
dt.sub(DT = dtbl, pattern = "hello", replacement = "goodbye")
}
\references{

}
\author{
Yoann Pageaud.
}
